// Получение ссылки на элемент canvas по его идентификатору
const cvs = document.querySelector('#canvas_plate');

// Получение 2D-контекста рисования для canvas
const ctx = cvs.getContext("2d");

// Создание массива для поля
const field = [
    [0, 0, 0],
    [0, 0, 0],
    [0, 0, 0],
];

// Текущий игрок: 1 - крестик, 2 - нолик
let currentPlayer = 1;

// Рисует крестик в заданных координатах (x, y)
function cross(x, y) {
    ctx.moveTo(x - 40, y - 40); // Перемещение курсора в контексте рисования на точку
    ctx.lineTo(x + 40, y + 40); // Проведение линии от текущей позиции курсора до точки

    ctx.moveTo(x - 40, y + 40);
    ctx.lineTo(x + 40, y - 40);
    ctx.stroke(); //Отрисовка линий
}

// Рисует нолик в заданных координатах (x, y)
function circle(x, y) {
    ctx.beginPath(); // Начинает новый путь в контексте рисования
    ctx.arc(x, y, 40, 0, Math.PI * 2); // Внешняя окружность
    ctx.stroke();
}

// Изменяет состояние массива field в соответствии с текущим игроком
function changeArray(row, col) { 
    if (field[row][col] === 0) { // Проверка: если ячейка пуста (значение 0), то можно ее занять текущим игроком
        field[row][col] = currentPlayer; // Запись в массив текущего игрока в указанной ячейке
        currentPlayer = (currentPlayer === 1) ? 2 : 1; // Смена текущего игрока на противоположного (1 становится 2, и наоборот)
    }
}

// Рисует игровое поле, разделяя его на девять клеток
function render() {
    ctx.moveTo(100, 0);
    ctx.lineTo(100, 300);

    ctx.moveTo(200, 0);
    ctx.lineTo(200, 300);

    ctx.moveTo(0, 100);
    ctx.lineTo(300, 100);

    ctx.moveTo(0, 200);
    ctx.lineTo(300, 200);

    ctx.stroke();
}

// Очищает canvas, затем вызывает render() для отрисовки игрового поля и рисует крестики и нолики
function draw() {
    //Очистка поля происходит для удаления прошлых результатов игры
    ctx.clearRect(0, 0, cvs.width, cvs.height);

    //Вызов отрисовки
    render();

    // Отрисовываем крестики и нолики на основе массива field
    for (let row = 0; row < 3; row++) { // Цикл, который проходит по каждой ячейке игрового поля (3x3)
        for (let col = 0; col < 3; col++) {
            // Рассчитывает координаты центра текущей ячейки
            const x = col * 100 + 50;
            const y = row * 100 + 50;

            if (field[row][col] === 1) { // Проверяет значение в текущей ячейке массива field
                cross(x, y); // Если в ячейке 1 (крестик), то рисует крестик в центре ячейки
            } else if (field[row][col] === 2) { // Если в ячейке 2 (нолик), то рисует нолик в центре ячейки
                circle(x, y);
            }
        }
    }

    // Проверяем наличие выигрышной комбинации
    const winner = checkWinner();
    if (winner) {
        ctx.beginPath();
        ctx.lineWidth = 5;
        if (winner.type === "row") {
            const y = winner.line * 100 + 50;
            ctx.moveTo(10, y);
            ctx.lineTo(290, y);
        } else if (winner.type === "col") {
            const x = winner.line * 100 + 50;
            ctx.moveTo(x, 10);
            ctx.lineTo(x, 290);
        } else if (winner.type === "diag" && winner.line === 0) {
            ctx.moveTo(10, 10);
            ctx.lineTo(290, 290);
        } else if (winner.type === "diag" && winner.line === 1) {
            ctx.moveTo(10, 290);
            ctx.lineTo(290, 10);
        }
        ctx.stroke();
    }
}

// Проверка наличия выигрышной комбинации
function checkWinner() {
    // Проверка по строкам и столбцам
    for (let i = 0; i < 3; i++) { //Инициализация переменной i, цикл выполняется пока i меньше 3, после каждого выполнение цикла i будет увеличиваться на 1
        // Проверка выигрыша по строке
        if (field[i][0] !== 0 && field[i][0] === field[i][1] && field[i][1] === field[i][2]) {
            return { type: "row", line: i }; //type: "row" указание типа выигрошной комбинации, строке i указывает где именно произошло воспадение
        }
        // Проверка выигрыша по столбцу
        if (field[0][i] !== 0 && field[0][i] === field[1][i] && field[1][i] === field[2][i]) {
            return { type: "col", line: i };
        }
    }

    // Проверка по диагоналям
    if (field[0][0] !== 0 && field[0][0] === field[1][1] && field[1][1] === field[2][2]) {
        return { type: "diag", line: 0 };
    }
    if (field[0][2] !== 0 && field[0][2] === field[1][1] && field[1][1] === field[2][0]) {
        return { type: "diag", line: 1 };
    }

    return null; // Нет выигрышной комбинации
}

// Обработчик события клика
cvs.addEventListener('click', function (event) {
    // Определение текущей ячейки
    const col = Math.floor((event.clientX - cvs.offsetLeft) / 100); //event.clientX - свойство описывающее координату точки X, cvs.offsetLeft свойство canvas предоставляющее расстояние от верхнего края canvas до верхней границы. 
    const row = Math.floor((event.clientY - cvs.offsetTop) / 100); //Math.floor() округляет полученное значение вниз до ближайшего целого числа.

    // Вызов функции для изменения массива и отрисовки
    changeArray(row, col);
    draw();
});

// Инициализация отрисовки при загрузке страницы
draw();


/*Задачи
1.Константа крестика. 
2.Константа нолика.
3.Обратиться к canvas.
4.Написать функцию отрисовки поля.
5.Написать функцию обработка нажатия и изменения массива.
6.Описать функцию отрисовки крестика.
7.Описать функцию отрисовки нолика.
8.Определить пользователя который ходит.
9.Функция на проверку наличия победителя.
10.Перечёркивать три элемента при наличии победителя.
11.Вывод сообщение о победе пользователя.
12.Обработка собития ничьи.
*/

/* Вопрос
Нужно ли отслеживать нажатие определённого пользователя?
*/

/* Логика программы

*/